<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
  <link rel="stylesheet" href="./assets/css/style.css" type="text/css" charset="utf-8">
  <script type="text/javascript" src="./assets/js/paper-full.min.js"></script>
</head>
<body>
  <div id="main">
  <div id="content">
    <p>
      <span class="kern">I</span>n memory of
      <span class="kern">J</span>osephine D. Agbeame.
    </p>
  </div>
  </div>
  <div class="q_back">
    <canvas id="canvas" resize></canvas>
  </div>
  <script type="text/paperscript" canvas="canvas">
    // Ported from original Metaball script by SATO Hiroyuki
    // http://park12.wakwak.com/~shp/lc/et/en_aics_script.html
    project.currentStyle = {
        fillColor: '#222222'
    };

    var handle_len_rate = 2.4;
    var circlePaths = [];
    var circlePoints = [];
    for (var x = 0; x < 5; x++) {
      for (var y = 0; y < 5; y++) {
        var point = new Point(x * 500, y * 500);
        var circle = new Path.Circle([point.x, point.y], 75);
        circle.fillColor.alpha = 0;
          circlePaths.push(circle);
        circlePoints.push(point);
      }
    }

    var largePoint = new Point(0, 0);
    var largeCircle = new Path.Circle([largePoint.x, largePoint.y], 150);
    circlePaths.push(largeCircle);
    circlePoints.push(largePoint);

    function onMouseMove(event) {
      largePoint = event.point;
    }

    function onFrame(event) {
      for (var i = 0, l = circlePaths.length - 1; i < l; i++) {
        var d = largeCircle.position.getDistance(circlePaths[i].position);
        if (d < 250) {
          circlePaths[i].position += (largeCircle.position - circlePaths[i].position) / 25;
        } else {
          circlePaths[i].position += (circlePoints[i] - circlePaths[i].position) / 100;
        }
      }

        for (var i = 0, l = circlePaths.length; i < l; i++) {
          circlePaths[i].fillColor.alpha = 0;
        }

        largeCircle.position = largePoint;
        largeCircle.fillColor.alpha = 1;

        generateConnections(circlePaths);
    }

    var connections;
    function generateConnections(paths) {
        if (connections)
            connections.remove();
        connections = new Group();
        for (var i = 0, l = paths.length; i < l; i++) {
              var path = metaball(largeCircle, paths[i], 0.5, handle_len_rate, 450);
              if (path) {
                  connections.appendTop(path);
                  path.removeOnMove();
              }
        }
    }

    generateConnections(circlePaths);

    // ---------------------------------------------
    function metaball(ball1, ball2, v, handle_len_rate, maxDistance) {
        var center1 = ball1.position;
        var center2 = ball2.position;
        var radius1 = ball1.bounds.width / 2;
        var radius2 = ball2.bounds.width / 2;
        var pi2 = Math.PI / 2;
        var d = center1.getDistance(center2);
        var u1, u2;

        if (radius1 == 0 || radius2 == 0)
            return;

        if (d > maxDistance)
          return;

        if (d <= Math.abs(radius1 - radius2)) {
            return;
        } else if (d < radius1 + radius2) { // case circles are overlapping
            u1 = Math.acos((radius1 * radius1 + d * d - radius2 * radius2) /
                    (2 * radius1 * d));
            u2 = Math.acos((radius2 * radius2 + d * d - radius1 * radius1) /
                    (2 * radius2 * d));
        } else {
            u1 = 0;
            u2 = 0;
        }

      ball1.fillColor.alpha = 1;
      ball2.fillColor.alpha = 1;

        var angle1 = (center2 - center1).getAngleInRadians();
        var angle2 = Math.acos((radius1 - radius2) / d);
        var angle1a = angle1 + u1 + (angle2 - u1) * v;
        var angle1b = angle1 - u1 - (angle2 - u1) * v;
        var angle2a = angle1 + Math.PI - u2 - (Math.PI - u2 - angle2) * v;
        var angle2b = angle1 - Math.PI + u2 + (Math.PI - u2 - angle2) * v;
        var p1a = center1 + getVector(angle1a, radius1);
        var p1b = center1 + getVector(angle1b, radius1);
        var p2a = center2 + getVector(angle2a, radius2);
        var p2b = center2 + getVector(angle2b, radius2);

        // define handle length by the distance between
        // both ends of the curve to draw
        var totalRadius = (radius1 + radius2);
        var d2 = Math.min(v * handle_len_rate, (p1a - p2a).length / totalRadius);

        // case circles are overlapping:
        d2 *= Math.min(1, d * 2 / (radius1 + radius2));

        radius1 *= d2;
        radius2 *= d2;

        var path = new Path([p1a, p2a, p2b, p1b]);
        path.style = ball1.style;
        path.closed = true;

        var segments = path.segments;
        segments[0].handleOut = getVector(angle1a - pi2, radius1);
        segments[1].handleIn = getVector(angle2a + pi2, radius2);
        segments[2].handleOut = getVector(angle2b - pi2, radius2);
        segments[3].handleIn = getVector(angle1b + pi2, radius1);
        return path;
    }

    // ------------------------------------------------
    function getVector(radians, length) {
        return new Point({
            // Convert radians to degrees:
            angle: radians * 180 / Math.PI,
            length: length
        });
    }
  </script>
</body>
</html>